/*
 * EEL4511_ADC.c
 *
 *  Created on: Oct 17, 2016
 *      Author: Adrian
 */

#include<DSP28x_Project.h>
#include "../include/EEL4511_ADC.h"

void Init_McBSPb_ADC(void)
{
	EALLOW;

	SysCtrlRegs.PCLKCR0.bit.MCBSPBENCLK = 1;//enable McBSPA clock signal for SRGR

	GpioCtrlRegs.GPAMUX2.bit.GPIO25 = 3; 	//GPIO25 = MDRA
	GpioCtrlRegs.GPAMUX2.bit.GPIO26 = 3; 	//GPIO26 = MCLKXA
	GpioCtrlRegs.GPAMUX2.bit.GPIO27 = 3; 	//GPIO27 = MFSXA

	//Step 1. Place the transmitter and receiver in reset.
	//McbspbRegs.SPCR2.bit.XRST 	= 0;
	//McbspbRegs.SPCR1.bit.RRST   = 0;
	McbspbRegs.SPCR1.all = 0;
	McbspbRegs.SPCR2.all = 0;

	//Step 2. Place the sample rate generator in reset.
	//McbspbRegs.SPCR2.bit.GRST   = 0;

	//Step 3. Program registers that affect SPI operation.
	McbspbRegs.SPCR1.bit.CLKSTP = 2;   	 	//CLKSTP bits in SPRC1 = 0b10
	McbspbRegs.PCR.bit.CLKXM    = 1;		//CLKXP in PCR = 0b0
	McbspbRegs.PCR.bit.CLKRP    = 1;		//CLKRP in PCR = 0b1
	McbspbRegs.PCR.bit.SCLKME   = 0;		//clock generated by the sample rate generator (CLKG) is derived from the CPU clock.
	McbspbRegs.SRGR2.bit.CLKSM  = 1;
	McbspbRegs.SRGR1.bit.CLKGDV = 8;		//divide clock by 4
	McbspbRegs.PCR.bit.FSXM	    = 1;        //FSR is output
	McbspbRegs.PCR.bit.FSXP     = 1;		//FSR is active low
	McbspbRegs.SRGR2.bit.FSGM   = 0;        //FSR = ~SS chip select
	McbspbRegs.XCR2.bit.XPHASE  = 0;
	McbspbRegs.RCR2.bit.RPHASE  = 0;
	McbspbRegs.XCR1.bit.XFRLEN1 = 0;
	McbspbRegs.XCR1.bit.XWDLEN1 = 4;
	McbspbRegs.RCR1.bit.RFRLEN1 = 0;
	McbspbRegs.RCR1.bit.RWDLEN1 = 4;
	McbspbRegs.XCR2.bit.XDATDLY = 1;
	McbspbRegs.RCR2.bit.RDATDLY = 1;

	//Step 4. Enable the sample rate generator.
	McbspbRegs.SPCR2.bit.GRST   = 1;

	//TODO: Workaround these offending delays
	//DELAY_US(100);
	for(int i = 0; i < 1000 ; i++);

	//Step 5. Enable the transmitter and receiver.
	McbspbRegs.SPCR2.bit.XRST 	= 1;
	McbspbRegs.SPCR1.bit.RRST   = 1;

	//TODO: Workaround these offending delays
	//DELAY_US(100);
	for(int i = 0; i < 1000 ; i++);

	McbspbRegs.SPCR2.bit.FRST = 1;

	EDIS;
}

Uint16 ADC_in(void)
{
	EALLOW;

	McbspbRegs.DXR2.all = 0xFFFF;
	McbspbRegs.DXR1.all = 0xFFFF;
	while( !McbspbRegs.SPCR1.bit.RRDY );
	Uint16 resultH = McbspbRegs.DRR2.all;
	Uint16 resultL = McbspbRegs.DRR1.all;

	resultH = (resultH << 14) & 0xC000 ;
	resultL &= 0xFFFC;
	resultL = resultL >> 2;

	Uint16 result = (resultH) | (resultL);


	EDIS;

	return result;
}
